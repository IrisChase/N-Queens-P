Presented for you is my first Java project. Please go easy on me with failings of style.

It is an implementation of my solution to the N Queens problem, with the additional constraint that no three queens form a line at any angle. This approach uses backtracking with recursion, the nice thing about that is that it not only guarantees a solution (if it exists), but can be used to find all possible solutions for a given N, this property is exploited to satisfy the "no line of three" constraint.

The performance of this solution is not ideal, but to me is acceptable, and I believe a good place to start. I would only go deeper in optimizations if absolutely necessary because I believe as it stands this is a nice balance between performance and maintainability.

I also felt, though didn't have time to test so caveat emptor, that storing the comparisons between each pair of queens as the positions that would violate that constraint would be more performant than comparing each combination of three queens every time we go to place a queen (as far as time complexity, worse for space, naturally), which lead me to marking up vulnerable positions in an NxN array.

Flagging the vulnerability of each position in an array also makes it easier to test visually. The marking functions are treated as 2D drawing functions, and the grid is rendered as a string for testing so that if it's wrong then jUnit prints out the grid expected and the one produced, allowing one to see very quickly at a glance what went wrong.

It might seem naive that I chose to make a new copy of the board for each attempt at placing a queen, but sometimes the naive approach is just nicer to deal with. I believe even Photoshop just stores a copy of the entire raster for each undo point now, greatly simplifying the actual act of "undoing". I used this approach because "unmarking" the grid would be tricky. The downside of course is that it causes the spatial complexity to jump from N^2 to N^3, because you have an additional NxN for each recursive call, and a recursion depth of N. The other issue is that I'm not sure what the performance/memory implications of allocating a new board every time a queen is placed are in Java, I know this would be a deep concern for me in C++, but I'm unaware of whether the JVM can do something like "placement new" internally to avoid a lag while searching for available memory in the heap (I would like to believe it could, given how smug Java developers are about that sort of thing), and I don't have any Java profiling tools setup, so if this is a performance issue then please forgive me.

What's probably less interesting but I'm proud of anyway for some reason is how I draw the line of positions that would make a line of three. By taking a vector between two queens which may be a boards length apart, and then scaling it down to the smallest vector made up of whole numbers, we have a minimum "jump" vector which can be used to iteratively draw from the queen which represents the origin of the original vector. Then by simply inverting it we can draw in the opposite direction. The class named "Point" for lack of a better word, is what helps facilitate this in a readable manner.
